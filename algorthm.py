# -*- coding: utf-8 -*-
"""Algorthm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e2E0WX0hG3i8gJDzeVrNtqF_6kj_aNmr
"""

def is_valid_npi_v2(npi):
    # Convert the NPI to a list of integers
    npi_digits = [int(digit) for digit in str(npi)]
    print('====='*10)
    print('NPI Digits:', npi_digits)

    # Step 1: Drop the check digit to form the payload
    payload = npi_digits[:-1]

    # Reverse payload
    payload = list(reversed(payload))
    print('Payload Digits:', payload)

    # Step 2: Double the value of every second digit (starting from the rightmost)
    doubled_digits = [2 * digit if idx % 2 == 0 else digit for idx, digit in enumerate(payload)]
    print('Doubled Digits:', doubled_digits)

    # Step 3: Sum the values of the resulting digits
    s = sum([digit // 10 + digit % 10 for digit in doubled_digits])
    print('Sum of Doubled Digits:', s)

    # Step 4: Calculate the check digit
    check_digit = (10 - (s % 10)) % 10
    print('Check Digit:', check_digit)

    # Check if the calculated check digit is equal to the original check digit
    return check_digit == npi_digits[-1]

# Test the function with your NPI numbers
npi_numbers = [1760661920, 1215155296, 1235134255, 1316924202, 1861935553, 1669569703]

for npi in npi_numbers:
    if is_valid_npi_v2(npi):
        print(f"{npi} is valid.")
    else:
        print(f"{npi} is not valid.")

def is_valid_npi_with_prefix(npi):
    # Convert the NPI to a list of integers
    npi_digits = [int(digit) for digit in str(npi)]

    print('====='*10)
    print('NPI Digits:', npi_digits)

    # Step 1: Drop the check digit to form the payload and prefix "80840"
    prefix = [8, 0, 8, 4, 0] + npi_digits[:-1]

    # Reverse the prefix to match the Luhn algorithm iteration
    payload = list(reversed(prefix))

    print('Payload Digits:', payload)

    # Step 2: Double the value of every second digit (starting from the rightmost)
    doubled_digits = [2 * digit if idx % 2 == 0 else digit for idx, digit in enumerate(payload)]

    print('Doubled Digits:', doubled_digits)

    # Step 3: Sum the values of the resulting digits
    s = sum([digit // 10 + digit % 10 for digit in doubled_digits])

    print('Sum of Doubled Digits:', s)

    # Step 4: Calculate the check digit
    check_digit = (10 - (s % 10)) % 10
    print('Check Digit:', check_digit)

    # Check if the calculated check digit is equal to the original check digit
    return check_digit == npi_digits[-1]

# Test the function with your NPI numbers
npi_numbers = [1760661920, 1215155296, 1235134255, 1316924202, 1861935553, 1669569703]

for npi in npi_numbers:
    if is_valid_npi_with_prefix(npi):
        print(f"{npi} is valid.")
    else:
        print(f"{npi} is not valid.")

def is_valid_luhn(digits):
    check_digit = 0
    for i in range(len(digits) - 2, -1, -1):
        check_digit += digits[i] * 2 - 9 if i % 2 == 0 and digits[i] > 4 else digits[i] if i % 2 == 0 else digits[i]

    return (10 - (check_digit % 10)) % 10 == digits[-1]

# Test the function with an example
digits_example = [1, 2, 3, 5, 1, 3, 4, 2, 5, 5]
result = is_valid_luhn(digits_example)
print(result)

def is_valid_npi_with_prefix(npi):
    # Convert the NPI to a list of integers
    npi_digits = [int(digit) for digit in str(npi)]
    print(npi_digits)

    # Step 1: Drop the check digit to form the payload and prefix "80840"
    payload = [8, 0, 8, 4, 0] + npi_digits[:-1]
    print(payload)

    # Step 2: Double the value of every second digit (starting from the rightmost)
    doubled_digits = [2 * digit if idx % 2 == 0 else digit for idx, digit in enumerate(reversed(payload))]
    print(doubled_digits)

    # Step 3: Sum the values of the resulting digits
    s = sum([digit // 10 + digit % 10 for digit in doubled_digits])

    # Step 4: Calculate the check digit
    check_digit = (10 - (s % 10)) % 10
    print(check_digit)

    # Check if the calculated check digit is equal to the original check digit
    return check_digit == npi_digits[-1]

# Test the function with the provided NPI numbers
npi_numbers = [1760661920, 1215155296, 1235134255, 1316924202, 1861935553, 1669569703]

for npi in npi_numbers:
    if is_valid_npi_with_prefix(npi):
        print(f"{npi} is valid.")
    else:
        print(f"{npi} is not valid.")

a = ['a', 'd', 3, 'v', 4, 'n', 5]

b = a[:-1]
b

ax = a[2:5]
ax

c = a[:6]
c

def is_valid_luhn(digits):
    check_digit = 0
    for i in range(len(digits) - 2, -1, -1):
        check_digit += digits[i] * 2 - 9 if i % 2 == 0 and digits[i] > 4 else digits[i] if i % 2 == 0 else digits[i]

    return (10 - (check_digit % 10)) % 10 == digits[-1]

# Test the function with NPI numbers
npi_numbers = [1760661920, 1215155296, 1235134255, 1316924202, 1861935553, 1669569703]

for npi in npi_numbers:
    npi_digits = [int(digit) for digit in str(npi)]
    result = is_valid_luhn(npi_digits)
    print(f"NPI: {npi}, Valid: {result}")

def is_valid_luhn(digits):
    check_digit = 0
    for i in range(len(digits) - 2, -1, -1):
        check_digit += digits[i] * 2 - 9 if i % 2 == 0 and digits[i] > 4 else digits[i] if i % 2 == 0 else digits[i]

    return (10 - (check_digit % 10)) % 10 == digits[-1]

# Test the function with NPI numbers
npi_numbers = [1760661920, 1215155296, 1235134255, 1316924202, 1861935553, 1669569703]

for npi in npi_numbers:
    # Convert NPI to a list of digits and add the prefix "80840"
    npi_digits = [int(digit) for digit in str(80840) + str(npi)]
    result = is_valid_luhn(npi_digits)
    print(f"NPI: {npi}, Valid: {result}")